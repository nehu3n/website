---
title: "Qipi: el gestor de paquetes m√°s r√°pido para Node.js ‚Äî sin node_modules, inst√°ntaneo y seguro"
description: "Se presenta Qipi, un gestor de paquetes extremadamente r√°pido para Node.js, escrito en Rust. Sin node_modules. Compatible con todo el ecosistema."
pubDate: "2025-07-16"
slug: "introducing-qipi"
tags: ["project", "rust"]
heroImage: "../assets/qipi-banner.png"
---

Hist√≥ricamente todos los gestores de paquetes de Node.js han intentado innovar en el manejo de dependencias. Algunos, como [pnpm](https://pnpm.io), optaron por emplear arquitecturas m√°s eficientes, usando _symlinks_ y cach√©s centralizadas, reduciendo el espacio necesario en disco y optimizando los tiempos de instalaci√≥n. Pero, a pesar de sus mejoras, sigue teniendo la misma problem√°tica general: la dependencia a `node_modules`. Esta estructura presenta ciertos inconvenientes:

- ‚Ä¢ Genera un grafo demasiado complejo de dependencias
- ‚Ä¢ Obliga al gestor a manejar casos excepcionales como referencias c√≠clicas
- ‚Ä¢ Infla el repositorio local con cientos o miles de archivos y directorios
- ‚Ä¢ El _resolver_ debe buscar recursivamente, decayendo en un c√≥mputo `O(n)` o peor

[Yarn PnP](https://yarnpkg.com) intent√≥ resolverlo creando un sistema de archivos por encima de una cach√© ZIP, donde se genera un archivo `.pnp.cjs` **por cada proyecto** con su grafo de dependencias incrustado. Luego, este archivo se carga como un _loader_ personalizado en Node.js, interceptando las llamadas a `require()`. Aunque es un adelanto, podr√≠a tener mejoras t√©cnicas y cr√≠ticas que pueden aumentar el rendimiento, eficiencia en disco y compatibilidad con el ecosistema significativamente. Ese es el objetivo de **Qipi**.

---

## üëã Introducci√≥n

[**Qipi**](https://github.com/qipkg/qipi) es un gestor de paquetes extremadamente r√°pido, muy eficiente en disco, seguro y determinista para Node.js, escrito en Rust. Sigue la arquitectura conceptual de Yarn PnP, en su filosof√≠a de "cero `node_modules`", pero con cambios y mejoras importantes en su implementaci√≥n. Algunas de sus caracter√≠sticas generales son:

- ‚Ä¢ Sin `node_modules`
- ‚Ä¢ Sin `.pnp.cjs` ni carpetas ocultas: **el repositorio queda limpio**
- ‚Ä¢ Compatibilidad total con el ecosistema de JavaScript, incluidas herramientas de desarrollo
- ‚Ä¢ Una √∫nica instalaci√≥n por paquete, deduplicada por siempre e indexada
- ‚Ä¢ Resoluciones de dependencias instant√°neas, por debajo del milisegundo
- ‚Ä¢ F√°cil, intuitivo y r√°pido de usar
- ‚Ä¢ Instalaciones de proyectos completos en menos de un segundo
- ‚Ä¢ Soporte a workspaces _plug-and-play_ y escalables
- ‚Ä¢ 100% multiplataforma

Para conseguirlo, **Qipi** aplica optimizaciones agresivas, incluidas mapeo perezoso en memoria (`mmap`) del grafo de dependencias, formatos binarios, indexaci√≥n `O(1)` para todo paquete solicitado, cach√© centralizada y deduplicada, _loader_ de Node.js escrito en Rust, montaje virtual para retrocompatibilidad, entre otras. En este post se va a repasar toda la arquitectura presentada, junto al proyecto.

---

## ü§î ¬øSin `node_modules`?

Seguramente una de las preguntas m√°s reiterativas es y ser√° _"¬øpor qu√© y c√≥mo no hay node_modules?"_. Esta decisi√≥n se debe a las razones dadas al principio, sumado a que implementar un gestor que lo utilice es m√°s complejo y pesado en comparaci√≥n de evitarlo.

Primero hay que presentar c√≥mo se inicia un proyecto en **Qipi**, donde se podr√° ver c√≥mo se estructura un repositorio. Lo primero es crear el directorio e iniciar el `shell`; _"¬øel shell?"_, s√≠.

```bash
qp new hello-world
cd hello-world
qp shell
```

Creamos la carpeta con `qp new name`. Esto va a hacer un _scaffold_ **minimo y muy limpio**, parte de la filosof√≠a de **Qipi**.

```text
üì¶hello-world
 ‚î£ üìúpackage.json
 ‚îó üìúpackage.lock
```

El archivo `package.json` es donde se centraliza toda la configuraci√≥n del proyecto, mientras que en el `package.lock` se crear√° el grafo binario de dependencias, usado para resolverlas de forma determinista, r√°pida y segura. Nada m√°s.

Luego, entramos al directorio con `cd name` y ejecutamos `qp shell`, ac√° es donde empiezan las diferencias. **Qipi** utiliza un _resolver_ personalizado para que Node.js pueda saber d√≥nde se almacenan las dependencias, ya que por defecto las buscar√° en `node_modules`, y al no existir, lanzar√° un error. 

El comando `qp shell` superpone el `$PATH` para que las llamadas a `node` incluyan una _flag_ `--import` y `--require`, apuntando al _loader_ personalizado. Esto se aplica **solo a la sesi√≥n actual del shell**, si abre una nueva terminal no se mantendr√° el cambio, por lo que es seguro al **no** modificar estados globales.

Dependiendo del sistema operativo y _shell_ en uso, se usar√° un _**shim**_ diferente, todos localizados en `$HOME/.qipi/shims/<os>/shim-<shell>.*`.

Ahora vamos a a√±adir una dependencia. Por ejemplo, [ms](https://npmjs.com/package/ms).

```bash
qp add ms
```

Esto no tomar√° m√°s de **300ms**. Pero, lo m√°s sorprendente es que no aparecer√° nada nuevo en el repositorio, m√°s que cambiaron `package.json` y `package.lock` para registrar la nueva dependencia. El flujo de instalaci√≥n interno fue el siguiente:

```mermaid
flowchart TD
  classDef default fill:transparent,stroke:#fff,stroke-width:2px,color:#fff,font-weight:bold,font-size:15px;
  class qpAdd,checkStore,condExist,writeLock,buildDAG,downloadDeps,checkSubDeps,updateLock,updateMmap default;

  linkStyle default stroke:#fff,stroke-width:2px;

  qpAdd(["Ejecuta qp add ms"])
  checkStore(["Verifica en el store global el paquete ms@latest"])
  condExist{"¬øExiste ms@latest?"}
  
  writeLock(["Escribe en package.lock y package.json"])
  buildDAG(["Arma grafo DAG de dependencias"])
  downloadDeps(["Descarga en store global descomprimido"])
  checkSubDeps(["Verifica sub-dependencias"])
  updateLock(["Actualiza package.lock y package.json"])

  qpAdd --> checkStore --> condExist
  condExist -- S√≠ --> writeLock
  condExist -- No --> buildDAG --> downloadDeps --> checkSubDeps --> updateLock

  condExist --- writeLock
  condExist --- buildDAG
```

El √∫nico I/O que se involucra es en la ausencia de un paquete en el [_store_ global](#-cach√©-global), descarg√°ndolo y posteriormente registr√°ndolo en el indexado del `package.lock` del proyecto. En caso de que ya est√© descargado, √∫nicamente es lo segundo.

Esto permite tiempos extremadamente r√°pidos, practicamente inmediatos, de instalaci√≥n. Adem√°s, se mantiene siempre limpio el repositorio, sin grandes estructuras de directorios y archivos anidados que inflan el _tree_ local.

---

## üìÉ Resoluci√≥n de dependencias

Ahora hay otra inc√≥gnita a responder: _"Sin un node_modules, ¬øc√≥mo hace Node.js para resolver las dependencias?"_. Ya se di√≥ pistas, pero ahora vamos a profundizar: el _resolver_ personalizado de **Qipi**.

Se dijo anteriormente que `qp shell` modificaba el `$PATH` de la sesi√≥n del _shell_ actual para interponer un `node` con las flags `--import` y `--require`. Esto permite, entre otras cosas, poder usar lo siguiente para ejecutar un proyecto:

```bash
node .
```

¬°S√≠! Puede ejecutar normalmente un proyecto JavaScript sin tener que llamar a `<pkgm> node .` (como Yarn) todo el tiempo, sin necesidad de grandes _wrappers_. Pero, ¬øc√≥mo funciona internamente?

Los _resolvers_ personalizados de m√≥dulos se introdujeron a Node.js en el a√±o **2023** con [la versi√≥n **v20.6.0**](https://nodejs.org/en/blog/release/v20.6.0#new-nodemodule-api-register-for-module-customization-hooks-new-initialize-hook), permitiendo modificar la l√≥gica de resoluci√≥n de m√≥dulos para cargar archivos de forma personalizada o con extensiones no est√°ndar.

En el caso de **Qipi**, los _resolvers_ est√°n localizados en `$HOME/.qipi/loaders/loader-esm.mjs` (**EcmaScript Modules, `--import`**) y `$HOME/.qipi/loaders/loader-common.cjs` (**CommonJS, `--require`**).

### üìÇ L√≥gica de carga

Tradicionalmente, los tiempos de carga suelen ser computados en `O(n)` o peor, debido a la estructura `node_modules`, que obliga a recorrer recursivamente. **Qipi** provee un nuevo algoritmo de resoluci√≥n con complejidad `O(1)`, lo que vuelve instant√°neo servir dependencias _on-demand_.

Esto es gracias al mapeo perezoso del _lockfile_ en memoria. [El formato del `package.lock`](#-lockfile) est√° dise√±ado para ser compatible con `mmap`. Al inicio del _resolver_ se carga una √∫nica vez el grafo de dependencias en memoria. Cada dependencia tiene un `MPHF` (_Minimal Perfect Hash Function_), que se usa de indice para acceder en `O(1)` a su _offset_ en memoria. Con el _offset_ obtenido, se accede a esa direcci√≥n en el grafo cargado en `mmap`, la cual retorna la ruta absoluta de la dependencia en el _store_.

Al ser _lazy-loading_, la paginaci√≥n solo se hace para las dependencias en demanda, evitando gasto de memoria en exceso. Solo se usa lo que se necesita. `mmap` habilita un mapeo _heap-less_, aumentando significativamente el rendimiento.

Todo esto se hace en una librer√≠a **Rust**, expuesta a JavaScript mediante [napi-rs](https://napi.rs). Aunque el _FFI_ tiene cierto coste, este es √≠nfimo, m√°s si se optimiza el traspaso de datos con canales _zero-copy_. Lo √∫nico que se env√≠a y devuelve son los identificadores `name@version` y la ruta absoluta de cada dependencia: _slices_ de bytes.

---

## ü§ñ Retrocompatibilidad

Uno de los mayores retos al prescindir del `node_modules` es mantener la retrocompatibilidad con herramientas heredadas. Algunos sistemas como `esbuild` y `vite` leen explicitamente y esperan una estructura `node_modules` en el proyecto, lo que rompe la compatibilidad con gestores de paquetes como Yarn PnP, necesitando de _hacks_ poco convencionales. **Qipi lo resuelve.**

En caso de que requiera compatibilidad, como se mencion√≥, solo deber√° ejecutar el siguiente comando:

```bash
qp mount
```

Internamente, `qp mount` utiliza **FUSE** (Linux/macOS) o **WinFSP** (Windows), para montar un `node_modules` en **memoria**, sin gastar espacio en disco. Esta capa de virtualizaci√≥n intercepta las _syscalls_ de cualquier herramienta (como `vite`), redirigiendo en un `resolver` propio las rutas del `node_modules` al _store_ global de **Qipi**, tambi√©n en `O(1)`. El _overhead_ de la capa de virtualizaci√≥n es minimo, a√±adiendo entre 2ms a 5ms, a cambio de la retrocompatibilidad completa con el ecosistema de Node.js.

Si quiere desmontar esta estructura virtual, puede usar:

```bash
qp umount
```

Y se destruir√° el `node_modules` en memoria de ese proyecto. Al instante.

---

## üîí _Lockfile_

A fin de reconstruir las dependencias de cada proyecto, es necesario guardar un grafo de forma determinista, segura y r√°pida; en **Qipi**, esto se logra con el `package.lock`. Vamos a ver c√≥mo est√° hecho.

Como se explic√≥ en [la l√≥gica de carga](#-l√≥gica-de-carga), el _lockfile_ es mapeado en memoria, por lo que es importante tener un formato compatible directamente con `mmap`. El archivo est√° dividido en tres secciones:

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Header del archivo          ‚îÇ ‚Üê version, hash algo, cantidad de entradas, offsets
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ √çndice MPHF de dependencias ‚îÇ ‚Üê minimal perfect hash (MPFF): name@version ‚Üí offset
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Tabla de Nodos (DAG)        ‚îÇ ‚Üê grafo actual: version, path resuelto, deps[]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> **Nota:** Si desea leerlo, puede transformar el _lockfile_ a un formato como `JSON`, `YAML` y `TOML` con el comando `qp lock --to <format>`. Debe tener en cuenta que **Qipi** no lee estos formatos, solo el `package.lock` binario original.

### üìã Header del archivo

La lectura del _lockfile_ empieza por el _header_. Esta secci√≥n contiene los metadatos necesarios para interpretar el resto.

- ‚Ä¢ `magic`: _string_ "m√°gico" (`b"QIPILOCK"`) para validar el formato.
- ‚Ä¢ `version`: versi√≥n del formato del _lockfile_.
- ‚Ä¢ `hash_algo`: identificador del algoritmo de _hash_ usado en el √≠ndice.
- ‚Ä¢ `entry_count`: cantidad total de nodos (dependencias) en el grafo.
- ‚Ä¢ `mphf_offset`: _offset_ donde comienza la tabla MPHF.
- ‚Ä¢ `node_table_offset`: _offset_ donde comienza la tabla de nodos.

Esto permite mapear con punteros de forma directa el contenido de las siguientes dos secciones, sin necesidad de _parsing_ l√≠nea a l√≠nea.

### üìë √çndice MPHF

Se usa un _Minimal Perfect Hash Function_ (`MPHF`) para mapear cada `name@version` a un _offset_ dentro de la [tabla de nodos](#-tabla-de-nodos). Esto permite que el acceso a las dependencias sea computado en `O(1)`, sin colisiones ni estructuras de datos complejas.

- ‚Ä¢ `Clave del hash`: _string_ `name@version`, codificado como UTF-8.
- ‚Ä¢ `Valor`: _offset_ absoluto (`u32`, `u64`) relativo al inicio del nodo (dependencia).

La idea con el `MPHF` es que, al generarse el grafo de forma inmutable y persistente en tiempo de instalaci√≥n (antes de _runtime_), se pueden precomputar todos los conjuntos de claves para mejorar el rendimiento y evitar calculos costosos en tiempo de ejecuci√≥n del _loader_.

### üîó Tabla de nodos

La tabla de nodos representa el grafo dirigido ac√≠clico (`DAG`) de dependencias. Cada entrada es un paquete √∫nico (`name@version`) y tiene:

- ‚Ä¢ `id`: identificador secuencial o hash del nodo.
- ‚Ä¢ `name`: nombre del paquete.
- ‚Ä¢ `version`: versi√≥n exacta.
- ‚Ä¢ `resolved_path`: path absoluto o relativo al paquete instalado.
- ‚Ä¢ `deps`: lista de _offsets_ a otras entradas en esta tabla (representan las dependencias directas).
- ‚Ä¢ **(opcional)** `integrity`, `tarball_url`, `flags`, `size`, `type_packaging`, etc.

Este dise√±o permite que, al hacer _load_ de un paquete ra√≠z, se puedan recorrer todas sus dependencias de forma descendente usando solo los _offsets_. No es necesario reconstruir el grafo, usar `JSON` o deserializar nada.

---

## üåé Cach√© global

**Qipi** almacena todas las dependencias en una cach√© (_store_) centralizada y deduplicada. Se localiza en `$HOME/.qipi/store` y su estructura est√° dise√±ada para ser plana y r√°pida de acceder.

```text
üì¶.qipi
 ‚îó üìÇstore
 ‚îÉ ‚î£ üìÇname@version1
 ‚îÉ ‚îó üìÇname@version2
```

Cada versi√≥n de las dependencias es una carpeta, por lo que permite hacer _lookup_ inmediato al combinarla simplemente con el nombre. Dentro de cada directorio, se agrega en tiempo de instalaci√≥n un archivo `.qipi-store-info` en formato binario que almacena informaci√≥n extra como el `integrity`, usada para verificaciones de seguridad y otras operaciones concurrentes.

### üóëÔ∏è Limpieza

Puede limpiar la cach√© de tres formas diferentes: **por dependencia**, **de forma total** y **autom√°ticamente**. 

La primer manera sirve para eliminar dependencias especificas.

```bash
qp store -r dep # qp store --remove dep
```

La segunda sirve para eliminar **todas las dependencias** del _store_.

```bash
qp store -c # qp store --clean
```

Y la tercera habilita un mecanismo de **recolecci√≥n de basura** autom√°tico.

```bash
qp store gc --enable # o para desactivar: qp store gc --disable
```

Cada vez que ejecute un comando (`qp add`, `qp remove`, `qp install`, etc.) el recolector verificar√° los `use_timestamp`, que guardan la √∫ltima fecha de uso de esa dependencia en un proyecto, almacenados en el `.qipi-store-info` de cada paquete. Si superan cierto umbral, los eliminar√°.

El umbral es configurable con el siguiente comando:

```bash
qp store gc -t 30d # qp store gc --threshold 30d
```

Los tiempos se deben expresar con sufijos: `min` (minutos), `h` (horas), `d` (d√≠as), `w` (semanas), `m` (meses).

---

## üì¶ _Workspaces_

Los _workspaces_ son una caracter√≠stica muy importante en la escalabilidad de proyectos. **Qipi** centraliza toda la configuraci√≥n en un √∫nico archivo `workspace.json`. Puede crearlo manualmente, o usar en un repositorio el siguiente comando:

```bash
qp init -w # qp init --workspace
```

Ahora puede listar los paquetes de la siguiente forma:

```json
{
  "members": ["packages/*"]
}
```

Luego, en la carpeta `packages`, puede empezar a crear sus miembros del _workspace_. Por ejemplo:

```
üì¶hello-world
 ‚î£ üìÇpackages
 ‚îÉ ‚î£ üìÇbar
 ‚îÉ ‚îÉ ‚î£ üìúpackage.json
 ‚îÉ ‚îÉ ‚îó üìúpackage.lock
 ‚îÉ ‚îó üìÇfoo
 ‚îÉ ‚îÉ ‚î£ üìúpackage.json
 ‚îÉ ‚îÉ ‚îó üìúpackage.lock
 ‚î£ üìúpackage.json
 ‚î£ üìúpackage.lock
 ‚îó üìúworkspace.json
```

Para agregar una dependencia a un paquete en especifico, use el siguiente comando:

```bash
qp add lodash -p bar # qp add lodash --package bar
```

En el caso de que sea un paquete interno del _workspace_, debe a√±adir expl√≠citamente el prefijo.

```bash
qp add workspace:foo -p bar # qp add workspace:foo --package bar
```

---

## ü§ù Contribuciones

**Qipi** est√° en constante desarrollo. Si le interes√≥ el proyecto, puede revisarlo en el [repositorio de GitHub](https://github.com/qipkg/qipi) y la [p√°gina web oficial](https://qipi.pages.dev). Todas las contribuciones son bienvenidas. **¬°Gracias por leer!**